#!/usr/bin/env bash

#Dump originator variables
declare -x ORIGINATOR_TYPE=""
declare -x ORIGINATOR_ID=""

# Redundant OS and Min FW Level
declare -x REDUNDANT_FW=""
declare -x MIN_FW_VERSION_LEVEL=""

# @brief fetch serial number
# @param serial number
function fetch_serial_number() {
    serialNo=$(busctl get-property xyz.openbmc_project.Inventory.Manager \
            /xyz/openbmc_project/inventory/system xyz.openbmc_project.Inventory.Decorator.Asset \
        SerialNumber | cut -d " " -f 2 | sed "s/^\(\"\)\(.*\)\1\$/\2/g")

    if [ -z "$serialNo" ]; then
        serialNo="0000000"
    fi
}

# @brief Add BMC dump File Name
# @param BMC Dump File Name
function get_bmc_dump_filename() {
    fetch_serial_number
    dump_id=$(printf %07d $dump_id)
    if [ $dump_type = "$TYPE_FAULTDATA" ]; then
        header_dump_name="FLTDUMP"
        name="NAGDUMP.${serialNo}.${dump_id}.${dDay}"
    else
        header_dump_name="BMCDUMP"
        name="BMCDUMP.${serialNo}.${dump_id}.${dDay}"
    fi
}

# @brief Function to get the Originator details
# @param Originator Type and Originator ID
function get_originator_details() {
    if [ -z "$dump_dir" ]; then
        return
    fi

    # A hash map for each possible dump types
    # Add/Remove as per the requirement
    local -A dump_name_map
    dump_name_map["faultlogs"]="faultlog"
    dump_name_map["opdump"]="system"
    dump_name_map["user"]="bmc"
    dump_name_map["elog"]="bmc"
    dump_name_map["dumps"]="bmc"

    dump_type_received="$dump_type"
    dump_entry_id="$dump_id"
    dump_type_mapped=""

    for key in "${!dump_name_map[@]}"
    do
        if [ "$key" = "$dump_type_received" ]; then
            dump_type_mapped="${dump_name_map[$key]}"
            break
        fi
    done

    # If the dump type received is not in the known list/map
    # then return then and there to avoid the dbus call which
    # would be definitely failed due to wrong object path string
    # made by th line
    # DBUS_DUMP_PATH="/xyz/openbmc_project/dump/$dump_type_mapped/entry/$dump_entry_id"
    if [ -z "$dump_type_mapped" ]; then
        return "$SUCCESS"
    fi

    if [ "$dump_type_mapped" = "bmc" ]; then
        dump_entry_id=$(echo "$dump_entry_id" | sed "s/^0*//")
    fi

    local DBUS_DUMP_MANAGER="xyz.openbmc_project.Dump.Manager"
    local DBUS_DUMP_PATH="/xyz/openbmc_project/dump/$dump_type_mapped/entry/$dump_entry_id"
    local DBUS_DUMP_ORIGINATROR_IFACE="xyz.openbmc_project.Common.OriginatedBy"
    local DBUS_ORIGINATOR_TYPE_STRING="OriginatorType"
    local DBUS_ORIGINATOR_ID_STRING="OriginatorId"

    ORIGINATOR_TYPE=$(busctl get-property "$DBUS_DUMP_MANAGER" \
            "$DBUS_DUMP_PATH" "$DBUS_DUMP_ORIGINATROR_IFACE" \
        "$DBUS_ORIGINATOR_TYPE_STRING")

    ORIGINATOR_ID=$(busctl get-property "$DBUS_DUMP_MANAGER" \
            "$DBUS_DUMP_PATH" "$DBUS_DUMP_ORIGINATROR_IFACE" \
        "$DBUS_ORIGINATOR_ID_STRING")

    # The following two lines would extract the originator type and id
    # from the received long string in response of the above dbus calls
    # like <s "xyz.openbmc_project.Common.OriginatedBy.OriginatorTypes.Internal">
    # to only <Internal> for the originator type and so on for the originator ID
    ORIGINATOR_TYPE=$(echo "$ORIGINATOR_TYPE" | cut -d' ' -f 2 \
        | cut -d'.' -f 6 | cut -d'"' -f 1)

    ORIGINATOR_ID=$(echo "$ORIGINATOR_ID" | cut -d' ' -f 2 \
        | cut -d'"' -f 1)

    # This hash map for Originator Type is populated based on
    # the info provided by the OriginatedBy.interface.yaml file under
    # https://github.com/openbmc/phosphor-dbus-interfaces/
    # Feel free to amend the table as per the evolving requirement
    local -A originator_type_enum_map
    originator_type_enum_map["Client"]=0
    originator_type_enum_map["Internal"]=1
    originator_type_enum_map["SupportingService"]=2

    local originator_type_mapped="$ORIGINATOR_TYPE"
    # If the originator type comes something which is not known to
    # the enum list/map then make it blank so that can be filled
    # with null bytes in gendumpheader script and won't be
    # breaking the dump extraction
    ORIGINATOR_TYPE=""
    for key in "${!originator_type_enum_map[@]}"
    do
        if [ "$key" = "$originator_type_mapped" ]; then
            ORIGINATOR_TYPE="${originator_type_enum_map[$key]}"
            break
        fi
    done
}

# @brief Get Redundant OS and Min FW version
function populate_redundant_os_n_min_fw_info()
{
    # Declare necessary dbus interfaces
    dbus_object="xyz.openbmc_project.Software.BMC.Updater"
    dbus_tree_command="busctl tree"
    dbus_property_command="busctl get-property"
    dbus_object_priority_method="xyz.openbmc_project.Software.RedundancyPriority"
    dbus_object_priority="Priority"
    dbus_object_version_method="xyz.openbmc_project.Software.Version"
    dbus_object_version="Version"
    dbus_object_min_version_method="xyz.openbmc_project.Software.MinimumVersion"
    dbus_object_min_version="MinimumVersion"

    # Declare an array to store the results of dbus command
    read_array=()

    IFS=$'\n' read -r -d '' -a read_array < <( eval "$dbus_tree_command" "$dbus_object" && printf '\0' )

    array_length=${#read_array[@]}

    # If there is only one FW image on the BMC, return then and there
    if [ "$array_length" -lt 5 ]; then
        return "$SUCCESS"
    fi

    firmware1=$(echo "${read_array[3]}" | xargs)
    firmware2=$(echo "${read_array[4]}" | xargs)

    if [ -n "$firmware1" ]; then
        firmware1=${firmware1:3}
    fi

    if [ -n "$firmware2" ]; then
        firmware2=${firmware2:3}
    fi

    # Get the priority of the image.
    # The one with the highest prirority amongst the two is the backup one
    # And the one with the lowest priority amongst the two is the active one
    dbus_command="$dbus_property_command $dbus_object $firmware1 \
        $dbus_object_priority_method $dbus_object_priority"

    firmware1_priority=$(eval "$dbus_command" | grep -w "1" | cut -d' ' -f 2)

    dbus_command="$dbus_property_command $dbus_object $firmware2 \
        $dbus_object_priority_method $dbus_object_priority"

    firmware2_priority=$(eval "$dbus_command" | grep -w "1" | cut -d' ' -f 2)

    # If FW1 is the redundant one then get the redundant info
    # else get the min FW version info
    if [ -n  "$firmware1_priority" ]; then
        dbus_command="$dbus_property_command $dbus_object $firmware1 \
            $dbus_object_version_method $dbus_object_version"
        REDUNDANT_FW=$(eval "$dbus_command" | cut -d' ' -f 2-)
    else
        dbus_command="$dbus_property_command $dbus_object $firmware1 \
            $dbus_object_min_version_method $dbus_object_min_version"
        MIN_FW_VERSION_LEVEL=$(eval "$dbus_command" | cut -d' ' -f 2-)
    fi
    # If FW2 is the redundant one then get the redundant info
    # else get the min FW version info
    if [ -n "$firmware2_priority" ]; then
        dbus_command="$dbus_property_command $dbus_object $firmware2 $dbus_object_version_method \
            $dbus_object_version"
        REDUNDANT_FW=$(eval "$dbus_command" | cut -d' ' -f 2-)
    else
        dbus_command="$dbus_property_command $dbus_object $firmware2 \
            $dbus_object_min_version_method $dbus_object_min_version"
        MIN_FW_VERSION_LEVEL=$(eval "$dbus_command" | cut -d' ' -f 2-)
    fi
}
